bedroom_mean = mean(housing_data$total_bedrooms, na.rm=TRUE)
#if(!require(Cairo)) install.packages("Cairo", repos = "http://cran.us.r-project.org")
#if(!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
#if(!require(car)) install.packages("car", repos = "http://cran.us.r-project.org")
library(readr)
library(ggplot2)
library(knitr)
library(tidyverse)
library(caret)
library(leaps)
library(car)
library(mice)
library(scales)
library(RColorBrewer)
library(plotly)
housing_data = read_csv("housing.csv")
housing_data$median_house_value[1:100]
set.seed(420)
housing_trn_idx = createDataPartition(housing_data$ocean_proximity, p = .70, list = FALSE)
housing_trn_data = housing_data[housing_trn_idx, ]
housing_tst_data = housing_data[-housing_trn_idx, ]
regsubsets.out = regsubsets(median_house_value ~ (longitude + latitude + housing_median_age + total_rooms + population + median_income + ocean_proximity) ^ 2,
data = housing_trn_data,
nbest = 1,     # 1 best model for each number of predictors
nvmax = 10,    # NULL for no limit on number of variables
force.in = NULL, force.out = NULL, method = "exhaustive", really.big=T)
# The output of this is long and not very pretty, there is better output below.
#regsubsets2.out
summary.out = summary(regsubsets.out)
dont_print_df = as.data.frame(summary.out$outmat)
## Adjusted R2
plot(regsubsets.out, scale = "adjr2", main = "Adjusted R^2")
#layout(matrix(1:2, ncol = 2))
## Adjusted R2
res.legend = subsets(regsubsets.out, statistic="adjr2", legend = FALSE, min.size = 5, main = "Adjusted R^2")
## Mallow Cp - A small value of Cp means that the model is relatively precise
#res.legend = subsets(regsubsets2.out, statistic="cp", legend = FALSE, min.size = 5, main = "Mallow Cp")
abline(a = 1, b = 1, lty = 2)
res.legend
which.max(summary.out$adjr2)
summary.out$which[which.max(summary.out$adjr2),]
best_adjr2 = summary.out$adjr2[which.max(summary.out$adjr2)]
full_twoway_model = twoway_mod_start = lm(median_house_value ~ (.)^2, data = housing_trn_data)
n = length(resid(full_twoway_model))
back_twoway_mod_finish_bic = step(full_twoway_model, direction = "backward", k = log(n), trace = 0)
back_twoway_mod_finish_aic = step(full_twoway_model, direction = "backward", trace = 0)
n = length(resid(full_twoway_model))
back_twoway_mod_finish_bic = step(full_twoway_model, direction = "backward", k = log(n), trace = 0)
back_twoway_mod_finish_aic = step(full_twoway_model, direction = "backward", trace = 0)
forward_twoway_mod_finish_bic = step(full_twoway_model, direction = "forward", k = log(n), trace = 0)
forward_twoway_mod_finish_aic = step(full_twoway_model, direction = "forward", trace = 0)
back_aic_mod_1 = step(best_leaps_model_1, direction = "backward", trace = 0)
pairs(housing_data, col = "dodgerblue")
housing_data$ocean_proximity = as.factor(housing_data$ocean_proximity)
ocean_proximity = housing_data$ocean_proximity
housing_data$total_bedrooms[is.na(housing_data$total_bedrooms)] = bedroom_median
bedroom_mean = mean(housing_data$total_bedrooms, na.rm=TRUE)
bedroom_median = median(housing_data$total_bedrooms, na.rm=TRUE)
ggplot(housing_data, aes(x = total_bedrooms)) +
geom_histogram(bins = 40, color = "black", fill = "blue") +
geom_vline(aes(xintercept = bedroom_mean, color = "Mean"), lwd = 1.5) +
geom_vline(aes(xintercept = bedroom_median, color = "Median"), lwd = 1.5) +
xlab("Total Bedrooms") +
ylab("Frequency") +
ggtitle("Histogram of Total Bedrooms (noncontinuous variable)") +
scale_color_manual(name = "Summary Stats", labels = c("Mean", "Median"), values = c("red", "green"))
housing_data$total_bedrooms[is.na(housing_data$total_bedrooms)] = bedroom_median
pairs(housing_data, col = "dodgerblue")
housing_data$total_bedrooms
housing_data$total_bedrooms / housing_data$total_rooms
housing_data$total_rooms / housing_data$total_bedrooms[1:100]
housing_data$households / housing_data$total_bedrooms
sum((predict(back_twoway_mod_finish_aic, housing_tst_data) - housing_tst_data$median_house_value)^2) / nrow(housing_tst_data)
rmse = function(predicted, actual) {
sqrt(sum((predicted - actual)^2) / length(actual))
}
rmse(predict(back_twoway_mod_finish_aic, housing_tst_data), housing_tst_data$median_house_value)
housing_tst_data
housing_data$ocean_proximity
housing_data$ocean_proximity == "ISLAND"
sum(housing_data$ocean_proximity == "ISLAND")
nrow(housing_data)
summary(back_twoway_mod_finish_aic)
housing_data$ocean_proximity = housing_data$ocean_proximity[-which(housing_data$ocean_proximity == "ISLAND")]
housing_data$ocean_proximity = as.factor(housing_data$ocean_proximity)
ocean_proximity = housing_data$ocean_proximity
housing_data$ocean_proximity = housing_data$ocean_proximity[-housing_data$ocean_proximity == "ISLAND")]
housing_data$ocean_proximity = as.factor(housing_data$ocean_proximity)
ocean_proximity = housing_data$ocean_proximity
housing_data$ocean_proximity = housing_data$ocean_proximity[-housing_data$ocean_proximity == "ISLAND"]
summary(housing_data)
housing_data$ocean_proximity = as.factor(housing_data$ocean_proximity)
housing_data$ocean_proximity = housing_data$ocean_proximity[-c(housing_data$ocean_proximity == "ISLAND")]
summary(housing_data)
housing_data$ocean_proximity = housing_data$ocean_proximity[c(housing_data$ocean_proximity != "ISLAND")]
summary(housing_data)
housing_data$ocean_proximity = as.factor(housing_data$ocean_proximity)
housing_data$ocean_proximity = housing_data$ocean_proximity[housing_data$ocean_proximity != "ISLAND"]
summary(housing_data)
housing_data = read_csv("housing.csv")
housing_data$median_house_value[1:100]
housing_data$ocean_proximity = as.factor(housing_data$ocean_proximity)
ocean_proximity = housing_data$ocean_proximity
housing_data$ocean_proximity = housing_data$ocean_proximity[housing_data$ocean_proximity != "ISLAND"]
housing_data$ocean_proximity = as.factor(housing_data$ocean_proximity)
ocean_proximity = housing_data$ocean_proximity
housing_data$ocean_proximity = housing_data$ocean_proximity[-housing_data$ocean_proximity != "ISLAND"]
housing_data = read_csv("housing.csv")
housing_data$median_house_value[1:100]
housing_data$ocean_proximity = as.factor(housing_data$ocean_proximity)
temp_housing_data = housing_data[housing_data_full$ocean_proximity != "ISLAND", ]
temp_housing_data = housing_data[housing_data$ocean_proximity != "ISLAND", ]
summary(housing_data)
nrow(temp_housing_data)
ggplot(housing_data, aes(x = ocean_proximity, y = len)) +
geom_bar(stat = "identity", color = "blue")
ggplot(housing_data, aes(x = ocean_proximity, y = sum(ocean_proximity))) +
geom_bar(stat = "identity", color = "blue")
ggplot(housing_data, aes(x = ocean_proximity, y = length(ocean_proximity))) +
geom_bar(stat = "identity", color = "blue")
ggplot(housing_data, aes(x = factor(ocean_proximity))) +
geom_bar(stat = "identity", color = "blue")
ggplot(housing_data, aes(x = factor(ocean_proximity))) +
geom_bar(stat = "bin", color = "blue")
ggplot(housing_data, aes(x = factor(ocean_proximity))) +
geom_bar(stat = "count", color = "blue")
ggplot(housing_data, aes(x = factor(ocean_proximity))) +
geom_bar(stat = "count", color = "blue", fill = "black")
ggplot(housing_data, aes(x = factor(ocean_proximity))) +
geom_bar(stat = "count", color = "black", fill = "blue")
count(ocean_proximity)
sum(ocean_proximity)
summary(housing_data$ocean_proximity)
diagnostics = function(model, alpha = .05, pointcol = "orange", linecol = "blue", plots = TRUE, tests = TRUE, pointtype = 16) {
if (plots == TRUE) {
par(mfrow = c(2,2))
plot(
fitted(model),
resid(model),
pch = pointtype,
xlab = "Fitted Values",
ylab = "Residuals",
main = "Fitted vs Residuals",
col = pointcol
)
abline(h = 0, lwd = 2, col = linecol)
qqnorm(
resid(model),
pch = pointtype,
main = "QQNorm Plot",
col = pointcol
)
qqline(
resid(model),
lwd = 2,
col = linecol
)
}
if (tests == TRUE) {
shapiro_test = shapiro.test(resid(model))
bp_test = bptest(model)
test_results = data.frame(
"Shapiro-Wilk Test" = c("Test Statistic" = shapiro_test$statistic,
"P-Value" = shapiro_test$p.value,
"Result" = ifelse(shapiro_test$p.value < alpha, "Reject", "Fail To Reject")
),
"Breusch-Pagan Test" = c("Test Statistic" = bp_test$statistic,
"P-Value" = bp_test_test$p.value,
"Result" = ifelse(bp_test$p.value < alpha, "Reject", "Fail To Reject")
)
)
kable(test_results)
}
}
housing_data = read_csv("housing.csv")
housing_data$median_house_value[1:100]
housing_data$ocean_proximity = as.factor(housing_data$ocean_proximity)
levels(housing_data$ocean_proximity)
housing_data = housing_data[housing_data$ocean_proximity != "ISLAND", ]
bedroom_mean = mean(housing_data$total_bedrooms, na.rm=TRUE)
bedroom_median = median(housing_data$total_bedrooms, na.rm=TRUE)
ggplot(housing_data, aes(x = total_bedrooms)) +
geom_histogram(bins = 40, color = "black", fill = "blue") +
geom_vline(aes(xintercept = bedroom_mean, color = "Mean"), lwd = 1.5) +
geom_vline(aes(xintercept = bedroom_median, color = "Median"), lwd = 1.5) +
xlab("Total Bedrooms") +
ylab("Frequency") +
ggtitle("Histogram of Total Bedrooms (noncontinuous variable)") +
scale_color_manual(name = "Summary Stats", labels = c("Mean", "Median"), values = c("red", "green"))
housing_data$total_bedrooms[is.na(housing_data$total_bedrooms)] = bedroom_median
if(!require(Cairo)) install.packages("Cairo", repos = "http://cran.us.r-project.org")
if(!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
if(!require(car)) install.packages("car", repos = "http://cran.us.r-project.org")
library(readr)
library(ggplot2)
library(knitr)
library(tidyverse)
library(caret)
library(leaps)
library(car)
library(mice)
library(scales)
library(RColorBrewer)
library(plotly)
set.seed(420)
housing_trn_idx = createDataPartition(housing_data$ocean_proximity, p = .70, list = FALSE)
housing_trn_data = housing_data[housing_trn_idx, ]
housing_tst_data = housing_data[-housing_trn_idx, ]
best_leaps_model_1 = lm(median_house_value ~ longitude + latitude + I(ocean_proximity == "INLAND") + I(ocean_proximity == "NEAR BAY") + longitude:latitude + longitude:median_income + longitude:I(ocean_proximity == "NEAR BAY") + housing_median_age:total_rooms + housing_median_age:population + population:median_income, data = housing_trn_data)
#summary(best_leaps_model_1)
names(coef(best_leaps_model_1))[-1]
best_leaps_model_2 = lm(median_house_value ~ housing_median_age + I(ocean_proximity == "INLAND") + I(ocean_proximity == "NEAR BAY") + longitude:housing_median_age + longitude:median_income + longitude:I(ocean_proximity == "NEAR BAY") + housing_median_age:total_rooms + housing_median_age:population, data = housing_trn_data)
summary(best_leaps_model_2)
names(coef(best_leaps_model_2))[-1]
best_leaps_model_3 = lm(median_house_value ~ median_income + I(ocean_proximity == "INLAND") + I(ocean_proximity == "NEAR BAY") + longitude:median_income + latitude:median_income + longitude:I(ocean_proximity == "NEAR BAY") + housing_median_age:total_rooms + housing_median_age:population, data = housing_trn_data)
summary(best_leaps_model_3)
names(coef(best_leaps_model_3))[-1]
full_twoway_model = twoway_mod_start = lm(median_house_value ~ (.)^2, data = housing_trn_data)
# full_twoway_model
# AIC
back_twoway_mod_finish_aic = step(full_twoway_model, direction = "backward", trace = 0)
forward_twoway_mod_finish_aic = step(full_twoway_model, direction = "forward", trace = 0)
# BIC
n = length(resid(full_twoway_model))
back_twoway_mod_finish_bic = step(full_twoway_model, direction = "backward", k = log(n), trace = 0)
forward_twoway_mod_finish_bic = step(full_twoway_model, direction = "forward", k = log(n), trace = 0)
# best_leaps_model_1
# AIC
back_aic_mod_1 = step(best_leaps_model_1, direction = "backward", trace = 0)
forward_aic_mod_1 = step(best_leaps_model_1, direction = "forward", trace = 0)
# BIC
n = length(resid(best_leaps_model_1))
back_bic_mod_1 = step(best_leaps_model_1, direction = "backward", k = log(n), trace = 0)
forward_bic_mod_1 = step(best_leaps_model_1, direction = "forward", k = log(n), trace = 0)
# best_leaps_model_2
# AIC
back_aic_mod_2 = step(best_leaps_model_2, direction = "backward", trace = 0)
forward_aic_mod_2 = step(best_leaps_model_2, direction = "forward", trace = 0)
# BIC
n = length(resid(best_leaps_model_2))
back_bic_mod_2 = step(best_leaps_model_2, direction = "backward", k = log(n), trace = 0)
forward_bic_mod_2 = step(best_leaps_model_2, direction = "forward", k = log(n), trace = 0)
# best_leaps_model_3
# AIC
back_aic_mod_3 = step(best_leaps_model_3, direction = "backward", trace = 0)
forward_aic_mod_3 = step(best_leaps_model_3, direction = "forward", trace = 0)
# BIC
n = length(resid(best_leaps_model_3))
back_bic_mod_3 = step(best_leaps_model_3, direction = "backward", k = log(n), trace = 0)
forward_bic_mod_3 = step(best_leaps_model_2, direction = "forward", k = log(n), trace = 0)
diagnostics = function(model, alpha = .05, pointcol = "orange", linecol = "blue", plots = TRUE, tests = TRUE, pointtype = 16) {
if (plots == TRUE) {
par(mfrow = c(2,2))
plot(
fitted(model),
resid(model),
pch = pointtype,
xlab = "Fitted Values",
ylab = "Residuals",
main = "Fitted vs Residuals",
col = pointcol
)
abline(h = 0, lwd = 2, col = linecol)
qqnorm(
resid(model),
pch = pointtype,
main = "QQNorm Plot",
col = pointcol
)
qqline(
resid(model),
lwd = 2,
col = linecol
)
}
if (tests == TRUE) {
shapiro_test = shapiro.test(resid(model))
bp_test = bptest(model)
test_results = data.frame(
"Shapiro-Wilk Test" = c("Test Statistic" = shapiro_test$statistic,
"P-Value" = shapiro_test$p.value,
"Result" = ifelse(shapiro_test$p.value < alpha, "Reject", "Fail To Reject")
),
"Breusch-Pagan Test" = c("Test Statistic" = bp_test$statistic,
"P-Value" = bp_test_test$p.value,
"Result" = ifelse(bp_test$p.value < alpha, "Reject", "Fail To Reject")
)
)
kable(test_results)
}
}
diagnostics(back_twoway_mod_finish_aic)
diagnostics(best_leaps_model_1)
diagnostics(back_aic_mod_2)
diagnostics(best_leaps_model_3)
install.packages("nortest")
library(nortest)
diagnostics = function(model, alpha = .05, pointcol = "orange", linecol = "blue", plots = TRUE, tests = TRUE, pointtype = 16) {
if (plots == TRUE) {
par(mfrow = c(2,2))
plot(
fitted(model),
resid(model),
pch = pointtype,
xlab = "Fitted Values",
ylab = "Residuals",
main = "Fitted vs Residuals",
col = pointcol
)
abline(h = 0, lwd = 2, col = linecol)
qqnorm(
resid(model),
pch = pointtype,
main = "QQNorm Plot",
col = pointcol
)
qqline(
resid(model),
lwd = 2,
col = linecol
)
}
if (tests == TRUE) {
ad_test = ad.test(resid(model))
bp_test = bptest(model)
test_results = data.frame(
"Anderson-Darling Normality Test" = c("Test Statistic" = ad_test$statistic,
"P-Value" = ad_test$p.value,
"Result" = ifelse(ad_test$p.value < alpha, "Reject", "Fail To Reject")
),
"Breusch-Pagan Test" = c("Test Statistic" = bp_test$statistic,
"P-Value" = bp_test_test$p.value,
"Result" = ifelse(bp_test$p.value < alpha, "Reject", "Fail To Reject")
)
)
kable(test_results)
}
}
diagnostics(back_twoway_mod_finish_aic)
diagnostics(best_leaps_model_1)
diagnostics(back_aic_mod_2)
diagnostics(best_leaps_model_3)
library(lmtest)
diagnostics(back_twoway_mod_finish_aic)
diagnostics(best_leaps_model_1)
diagnostics(back_aic_mod_2)
diagnostics(best_leaps_model_3)
diagnostics = function(model, alpha = .05, pointcol = "orange", linecol = "blue", plots = TRUE, tests = TRUE, pointtype = 16) {
if (plots == TRUE) {
par(mfrow = c(2,2))
plot(
fitted(model),
resid(model),
pch = pointtype,
xlab = "Fitted Values",
ylab = "Residuals",
main = "Fitted vs Residuals",
col = pointcol
)
abline(h = 0, lwd = 2, col = linecol)
qqnorm(
resid(model),
pch = pointtype,
main = "QQNorm Plot",
col = pointcol
)
qqline(
resid(model),
lwd = 2,
col = linecol
)
}
if (tests == TRUE) {
ad_test = ad.test(resid(model))
bp_test = bptest(model)
test_results = data.frame(
"Anderson-Darling Normality Test" = c("Test Statistic" = ad_test$statistic,
"P-Value" = ad_test$p.value,
"Result" = ifelse(ad_test$p.value < alpha, "Reject", "Fail To Reject")
),
"Breusch-Pagan Test" = c("Test Statistic" = bp_test$statistic,
"P-Value" = bp_test$p.value,
"Result" = ifelse(bp_test$p.value < alpha, "Reject", "Fail To Reject")
)
)
kable(test_results)
}
}
diagnostics(back_twoway_mod_finish_aic)
diagnostics(best_leaps_model_1)
diagnostics(back_aic_mod_2)
diagnostics(best_leaps_model_3)
diagnostics = function(model, alpha = .05, pointcol = "orange", linecol = "blue", plots = TRUE, tests = TRUE, pointtype = 16) {
if (plots == TRUE) {
par(mfrow = c(2,2))
plot(
fitted(model),
resid(model),
pch = pointtype,
xlab = "Fitted Values",
ylab = "Residuals",
main = "Fitted vs Residuals",
col = pointcol
)
abline(h = 0, lwd = 2, col = linecol)
qqnorm(
resid(model),
pch = pointtype,
main = "QQNorm Plot",
col = pointcol
)
qqline(
resid(model),
lwd = 2,
col = linecol
)
}
if (tests == TRUE) {
ad_test = ad.test(resid(model))
bp_test = bptest(model)
test_results = data.frame(
"Anderson-Darling Normality Test" = c("Test Statistic" = ad_test$statistic,
"P-Value" = ad_test$p.value,
"Result" = ifelse(ad_test$p.value < alpha, "Reject", "Fail To Reject")
),
"Breusch-Pagan Test" = c("Test Statistic" = bp_test$statistic,
"P-Value" = bp_test$p.value,
"Result" = ifelse(bp_test$p.value < alpha, "Reject", "Fail To Reject")
)
)
kable(t(test_results))
}
}
diagnostics(back_twoway_mod_finish_aic)
diagnostics(best_leaps_model_1)
diagnostics(back_aic_mod_2)
diagnostics(best_leaps_model_3)
