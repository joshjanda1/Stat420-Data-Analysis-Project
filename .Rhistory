par(mfrow = c(3,1))
plot(
fitted(model),
resid(model),
pch = pointtype,
xlab = "Fitted Values",
ylab = "Residuals",
main = "Fitted vs Residuals",
col = pointcol
)
abline(h = 0, lwd = 2, col = linecol)
qqnorm(
resid(model),
pch = pointtype,
main = "QQNorm Plot",
col = pointcol
)
qqline(
resid(model),
lwd = 2,
col = linecol
)
hist(
resid(model)
)
}
if (tests == TRUE) {
ad_test = ad.test(resid(model))
bp_test = bptest(model)
test_results = data.frame(
"Anderson-Darling Normality Test" = c("Test Statistic" = ad_test$statistic,
"P-Value" = ad_test$p.value,
"Result" = ifelse(ad_test$p.value < alpha, "Reject", "Fail To Reject")
),
"Breusch-Pagan Test" = c("Test Statistic" = bp_test$statistic,
"P-Value" = bp_test$p.value,
"Result" = ifelse(bp_test$p.value < alpha, "Reject", "Fail To Reject")
)
)
kable(t(test_results), col.names = c("Test Statistic", "P-Value", "Decision"), digits = 2)
}
}
diagnostics(back_twoway_mod_finish_aic)
diagnostics(best_leaps_model_1)
diagnostics(back_aic_mod_2)
diagnostics(best_leaps_model_3)
diagnostics = function(model, alpha = .05, pointcol = "orange", linecol = "blue", plots = TRUE, tests = TRUE, pointtype = 16) {
if (plots == TRUE) {
par(mfrow = c(1, 3))
plot(
fitted(model),
resid(model),
pch = pointtype,
xlab = "Fitted Values",
ylab = "Residuals",
main = "Fitted vs Residuals",
col = pointcol
)
abline(h = 0, lwd = 2, col = linecol)
qqnorm(
resid(model),
pch = pointtype,
main = "QQNorm Plot",
col = pointcol
)
qqline(
resid(model),
lwd = 2,
col = linecol
)
hist(
resid(model)
)
}
if (tests == TRUE) {
ad_test = ad.test(resid(model))
bp_test = bptest(model)
test_results = data.frame(
"Anderson-Darling Normality Test" = c("Test Statistic" = ad_test$statistic,
"P-Value" = ad_test$p.value,
"Result" = ifelse(ad_test$p.value < alpha, "Reject", "Fail To Reject")
),
"Breusch-Pagan Test" = c("Test Statistic" = bp_test$statistic,
"P-Value" = bp_test$p.value,
"Result" = ifelse(bp_test$p.value < alpha, "Reject", "Fail To Reject")
)
)
kable(t(test_results), col.names = c("Test Statistic", "P-Value", "Decision"), digits = 2)
}
}
diagnostics(back_twoway_mod_finish_aic)
diagnostics(best_leaps_model_1)
diagnostics(back_aic_mod_2)
diagnostics(best_leaps_model_3)
?par
diagnostics = function(model, alpha = .05, pointcol = "orange", linecol = "blue", plots = TRUE, tests = TRUE, pointtype = 16) {
if (plots == TRUE) {
par(mfrow = c(1, 3))
plot(
fitted(model),
resid(model),
pch = pointtype,
xlab = "Fitted Values",
ylab = "Residuals",
main = "Fitted vs Residuals",
col = pointcol
)
abline(h = 0, lwd = 2, col = linecol)
qqnorm(
resid(model),
pch = pointtype,
main = "QQNorm Plot",
col = pointcol
)
qqline(
resid(model),
lwd = 2,
col = linecol
)
hist(
resid(model),
main = "Histogram of Residuals",
col = "orange",
xlab = "Residuals",
ylab = "Frequency"
)
}
if (tests == TRUE) {
ad_test = ad.test(resid(model))
bp_test = bptest(model)
test_results = data.frame(
"Anderson-Darling Normality Test" = c("Test Statistic" = ad_test$statistic,
"P-Value" = ad_test$p.value,
"Result" = ifelse(ad_test$p.value < alpha, "Reject", "Fail To Reject")
),
"Breusch-Pagan Test" = c("Test Statistic" = bp_test$statistic,
"P-Value" = bp_test$p.value,
"Result" = ifelse(bp_test$p.value < alpha, "Reject", "Fail To Reject")
)
)
kable(t(test_results), col.names = c("Test Statistic", "P-Value", "Decision"), digits = 2)
}
}
diagnostics(back_twoway_mod_finish_aic)
diagnostics(best_leaps_model_1)
diagnostics(back_aic_mod_2)
diagnostics(best_leaps_model_3)
diagnostics = function(model, alpha = .05, pointcol = "orange", linecol = "blue", plots = TRUE, tests = TRUE, pointtype = 16) {
if (plots == TRUE) {
par(mfrow = c(1, 3))
plot(
fitted(model),
resid(model),
pch = pointtype,
xlab = "Fitted Values",
ylab = "Residuals",
main = "Fitted vs Residuals",
col = pointcol
)
abline(h = 0, lwd = 2, col = linecol)
qqnorm(
resid(model),
pch = pointtype,
main = "QQNorm Plot",
col = pointcol
)
qqline(
resid(model),
lwd = 2,
col = linecol
)
hist(
resid(model),
main = "Histogram of Residuals",
col = pointcol,
xlab = "Residuals",
ylab = "Frequency"
)
}
if (tests == TRUE) {
ad_test = ad.test(resid(model))
bp_test = bptest(model)
test_results = data.frame(
"Anderson-Darling Normality Test" = c("Test Statistic" = ad_test$statistic,
"P-Value" = ad_test$p.value,
"Result" = ifelse(ad_test$p.value < alpha, "Reject", "Fail To Reject")
),
"Breusch-Pagan Test" = c("Test Statistic" = bp_test$statistic,
"P-Value" = bp_test$p.value,
"Result" = ifelse(bp_test$p.value < alpha, "Reject", "Fail To Reject")
)
)
kable(t(test_results), col.names = c("Test Statistic", "P-Value", "Decision"), digits = 2)
}
}
diagnostics = function(model, alpha = .05, pointcol = "orange", linecol = "blue", plots = TRUE, tests = TRUE, pointtype = 16) {
if (plots == TRUE) {
par(mfrow = c(1, 3))
plot(
fitted(model),
resid(model),
pch = pointtype,
xlab = "Fitted Values",
ylab = "Residuals",
main = "Fitted vs Residuals",
col = pointcol
)
abline(h = 0, lwd = 2, col = linecol)
qqnorm(
resid(model),
pch = pointtype,
main = "QQNorm Plot",
col = pointcol
)
qqline(
resid(model),
lwd = 2,
col = linecol
)
hist(
resid(model),
main = "Histogram of Residuals",
col = pointcol,
xlab = "Residuals",
ylab = "Frequency"
)
}
if (tests == TRUE) {
ad_test = ad.test(resid(model))
bp_test = bptest(model)
test_results = data.frame(
"Anderson-Darling Normality Test" = c("Test Statistic" = ad_test$statistic,
"P-Value" = ad_test$p.value,
"Result" = ifelse(ad_test$p.value < alpha, "Reject", "Fail To Reject")
),
"Breusch-Pagan Test" = c("Test Statistic" = bp_test$statistic,
"P-Value" = bp_test$p.value,
"Result" = ifelse(bp_test$p.value < alpha, "Reject", "Fail To Reject")
)
)
kable(t(test_results), col.names = c("Test Statistic", "P-Value", "Decision"), digits = 5)
}
}
diagnostics(back_twoway_mod_finish_aic)
diagnostics(best_leaps_model_1)
diagnostics(back_aic_mod_2)
diagnostics(best_leaps_model_3)
?round
?round
round(1000.0030932, 5)
round(1000.0030932, 7)
round(1000.0030932, 10)
round(1920832, 3)
round(1920832, digits = 3)
?round
signif(139283, 3)
trunc(1020398, 3)
round(12038.98333, 1)
round(12038.98333, 2)
diagnostics = function(model, alpha = .05, pointcol = "orange", linecol = "blue", plots = TRUE, tests = TRUE, pointtype = 16) {
if (plots == TRUE) {
par(mfrow = c(1, 3))
plot(
fitted(model),
resid(model),
pch = pointtype,
xlab = "Fitted Values",
ylab = "Residuals",
main = "Fitted vs Residuals",
col = pointcol
)
abline(h = 0, lwd = 2, col = linecol)
qqnorm(
resid(model),
pch = pointtype,
main = "QQNorm Plot",
col = pointcol
)
qqline(
resid(model),
lwd = 2,
col = linecol
)
hist(
resid(model),
main = "Histogram of Residuals",
col = pointcol,
xlab = "Residuals",
ylab = "Frequency"
)
}
if (tests == TRUE) {
ad_test = ad.test(resid(model))
bp_test = bptest(model)
test_results = data.frame(
"Anderson-Darling Normality Test" = c("Test Statistic" = round(ad_test$statistic, 5),
"P-Value" = round(ad_test$p.value, 5),
"Result" = ifelse(ad_test$p.value < alpha, "Reject", "Fail To Reject")
),
"Breusch-Pagan Test" = c("Test Statistic" = round(bp_test$statistic, 5),
"P-Value" = round(bp_test$p.value, 5),
"Result" = ifelse(bp_test$p.value < alpha, "Reject", "Fail To Reject")
)
)
kable(t(test_results), col.names = c("Test Statistic", "P-Value", "Decision"), digits = 5)
}
}
diagnostics = function(model, alpha = .05, pointcol = "orange", linecol = "blue", plots = TRUE, tests = TRUE, pointtype = 16) {
if (plots == TRUE) {
par(mfrow = c(1, 3))
plot(
fitted(model),
resid(model),
pch = pointtype,
xlab = "Fitted Values",
ylab = "Residuals",
main = "Fitted vs Residuals",
col = pointcol
)
abline(h = 0, lwd = 2, col = linecol)
qqnorm(
resid(model),
pch = pointtype,
main = "QQNorm Plot",
col = pointcol
)
qqline(
resid(model),
lwd = 2,
col = linecol
)
hist(
resid(model),
main = "Histogram of Residuals",
col = pointcol,
xlab = "Residuals",
ylab = "Frequency"
)
}
if (tests == TRUE) {
ad_test = ad.test(resid(model))
bp_test = bptest(model)
test_results = data.frame(
"Anderson-Darling Normality Test" = c("Test Statistic" = round(ad_test$statistic, 5),
"P-Value" = round(ad_test$p.value, 5),
"Result" = ifelse(ad_test$p.value < alpha, "Reject", "Fail To Reject")
),
"Breusch-Pagan Test" = c("Test Statistic" = round(bp_test$statistic, 5),
"P-Value" = round(bp_test$p.value, 5),
"Result" = ifelse(bp_test$p.value < alpha, "Reject", "Fail To Reject")
)
)
kable(t(test_results), col.names = c("Test Statistic", "P-Value", "Decision"))
}
}
diagnostics(back_twoway_mod_finish_aic)
diagnostics(best_leaps_model_1)
diagnostics(back_aic_mod_2)
diagnostics(best_leaps_model_3)
?ad_test
library(nortest)
?ad.test
back_twoway_mod_finish_aic
back_twoway_mod_finish_aic$model
back_twoway_mod_finish_aic$call
back_twoway_mod_finish_aic_log = lm(formula = log(median_house_value) ~ longitude + latitude + housing_median_age +
total_rooms + total_bedrooms + population + households +
median_income + ocean_proximity + avg_bedrooms_per_household +
longitude:latitude + longitude:housing_median_age + longitude:total_rooms +
longitude:total_bedrooms + longitude:households + longitude:median_income +
longitude:ocean_proximity + longitude:avg_bedrooms_per_household +
latitude:housing_median_age + latitude:total_rooms + latitude:total_bedrooms +
latitude:households + latitude:median_income + latitude:ocean_proximity +
latitude:avg_bedrooms_per_household + housing_median_age:total_rooms +
housing_median_age:total_bedrooms + housing_median_age:population +
housing_median_age:households + housing_median_age:median_income +
housing_median_age:ocean_proximity + housing_median_age:avg_bedrooms_per_household +
total_rooms:population + total_rooms:households + total_rooms:median_income +
total_rooms:ocean_proximity + total_bedrooms:households +
total_bedrooms:median_income + total_bedrooms:ocean_proximity +
population:households + population:median_income + population:ocean_proximity +
population:avg_bedrooms_per_household + households:median_income +
households:ocean_proximity + median_income:ocean_proximity +
median_income:avg_bedrooms_per_household + ocean_proximity:avg_bedrooms_per_household, data = housing_trn_data)
diagnostics(back_twoway_mod_finish_aic_log)
library(lmtest)
library(knitr)
back_twoway_mod_finish_aic_log = lm(formula = log(median_house_value) ~ longitude + latitude + housing_median_age +
total_rooms + total_bedrooms + population + households +
median_income + ocean_proximity + avg_bedrooms_per_household +
longitude:latitude + longitude:housing_median_age + longitude:total_rooms +
longitude:total_bedrooms + longitude:households + longitude:median_income +
longitude:ocean_proximity + longitude:avg_bedrooms_per_household +
latitude:housing_median_age + latitude:total_rooms + latitude:total_bedrooms +
latitude:households + latitude:median_income + latitude:ocean_proximity +
latitude:avg_bedrooms_per_household + housing_median_age:total_rooms +
housing_median_age:total_bedrooms + housing_median_age:population +
housing_median_age:households + housing_median_age:median_income +
housing_median_age:ocean_proximity + housing_median_age:avg_bedrooms_per_household +
total_rooms:population + total_rooms:households + total_rooms:median_income +
total_rooms:ocean_proximity + total_bedrooms:households +
total_bedrooms:median_income + total_bedrooms:ocean_proximity +
population:households + population:median_income + population:ocean_proximity +
population:avg_bedrooms_per_household + households:median_income +
households:ocean_proximity + median_income:ocean_proximity +
median_income:avg_bedrooms_per_household + ocean_proximity:avg_bedrooms_per_household, data = housing_trn_data)
diagnostics(back_twoway_mod_finish_aic_log)
diagnostics(back_twoway_mod_finish_aic)
# From the text: http://daviddalpiaz.github.io/appliedstats/variable-selection-and-model-building.html
calc_loocv_rmse = function(model) {
sqrt(mean((resid(model) / (1 - hatvalues(model))) ^ 2))
}
calc_loocv_rmse(back_twoway_mod_finish_aic)
calc_loocv_rmse(best_exhaustive_model_1)
best_exhaustive_model_1 = lm(median_house_value ~ longitude + latitude + I(ocean_proximity == "INLAND") + I(ocean_proximity == "NEAR BAY") + longitude:latitude + longitude:median_income + longitude:I(ocean_proximity == "NEAR BAY") + housing_median_age:total_rooms + housing_median_age:population + population:median_income, data = housing_trn_data)
summary(best_exhaustive_model_1)$"adj.r.squared"
#names(coef(best_exhaustive_model_1))[-1]
best_exhaustive_model_2 = lm(median_house_value ~ housing_median_age + I(ocean_proximity == "INLAND") + I(ocean_proximity == "NEAR BAY") + longitude:housing_median_age + longitude:median_income + longitude:I(ocean_proximity == "NEAR BAY") + housing_median_age:total_rooms + housing_median_age:population, data = housing_trn_data)
summary(best_exhaustive_model_2)$"adj.r.squared"
#names(coef(best_exhaustive_model_2))[-1]
best_exhaustive_model_3 = lm(median_house_value ~ median_income + I(ocean_proximity == "INLAND") + I(ocean_proximity == "NEAR BAY") + longitude:median_income + latitude:median_income + longitude:I(ocean_proximity == "NEAR BAY") + housing_median_age:total_rooms + housing_median_age:population, data = housing_trn_data)
summary(best_exhaustive_model_3)$"adj.r.squared"
#names(coef(best_exhaustive_model_3))[-1]
calc_loocv_rmse(back_twoway_mod_finish_aic)
calc_loocv_rmse(best_exhaustive_model_1)
calc_loocv_rmse(back_aic_mod_2)
calc_loocv_rmse(best_exhaustive_model_3)
housing_tst_data
housing_data$ocean_proximity = as.factor(housing_data$ocean_proximity)
levels(housing_data$ocean_proximity)
housing_data = housing_data[housing_data$ocean_proximity != "ISLAND", ]
housing_data$total_bedrooms[is.na(housing_data$total_bedrooms)] = bedroom_median
set.seed(420)
housing_trn_idx = createDataPartition(housing_data$ocean_proximity, p = .70, list = FALSE)
library(boot)
set.seed(420)
housing_trn_idx = createDataPartition(housing_data$ocean_proximity, p = .70, list = FALSE)
library(mice)
library(caret)
set.seed(420)
housing_trn_idx = createDataPartition(housing_data$ocean_proximity, p = .70, list = FALSE)
housing_trn_data = housing_data[housing_trn_idx, ]
housing_tst_data = housing_data[-housing_trn_idx, ]
predicted_best = predict(back_twoway_mod_finish_aic, housing_tst_data)
full_twoway_model = twoway_mod_start = lm(median_house_value ~ (.)^2, data = housing_trn_data)
twoway_adjr2 = summary(full_twoway_model)$adj.r.squared
# full_twoway_model
# AIC
back_twoway_mod_finish_aic = step(full_twoway_model, direction = "backward", trace = 0)
both_twoway_mod_finish_aic = step(full_twoway_model, direction = "both", trace = 0)
# BIC
n = length(resid(full_twoway_model))
back_twoway_mod_finish_bic = step(full_twoway_model, direction = "backward", k = log(n), trace = 0)
both_twoway_mod_finish_bic = step(full_twoway_model, direction = "both", k = log(n), trace = 0)
# best_exhaustive_model_1
# AIC
back_aic_mod_1 = step(best_exhaustive_model_1, direction = "backward", trace = 0)
both_aic_mod_1 = step(best_exhaustive_model_1, direction = "both", trace = 0)
# BIC
n = length(resid(best_exhaustive_model_1))
back_bic_mod_1 = step(best_exhaustive_model_1, direction = "backward", k = log(n), trace = 0)
both_bic_mod_1 = step(best_exhaustive_model_1, direction = "both", k = log(n), trace = 0)
# best_exhaustive_model_2
# AIC
back_aic_mod_2 = step(best_exhaustive_model_2, direction = "backward", trace = 0)
both_aic_mod_2 = step(best_exhaustive_model_2, direction = "both", trace = 0)
# BIC
n = length(resid(best_exhaustive_model_2))
back_bic_mod_2 = step(best_exhaustive_model_2, direction = "backward", k = log(n), trace = 0)
both_bic_mod_2 = step(best_exhaustive_model_2, direction = "both", k = log(n), trace = 0)
# best_exhaustive_model_3
# AIC
back_aic_mod_3 = step(best_exhaustive_model_3, direction = "backward", trace = 0)
both_aic_mod_3 = step(best_exhaustive_model_3, direction = "both", trace = 0)
# BIC
n = length(resid(best_exhaustive_model_3))
back_bic_mod_3 = step(best_exhaustive_model_3, direction = "backward", k = log(n), trace = 0)
both_bic_mod_3 = step(best_exhaustive_model_2, direction = "both", k = log(n), trace = 0)
calc_loocv_rmse(back_twoway_mod_finish_aic)
calc_loocv_rmse(best_exhaustive_model_1)
calc_loocv_rmse(back_aic_mod_2)
calc_loocv_rmse(best_exhaustive_model_3)
predicted_best = predict(back_twoway_mod_finish_aic, housing_tst_data)
calc_rmse(housing_tst_data$median_house_value)
# From the text: http://daviddalpiaz.github.io/appliedstats/variable-selection-and-model-building.html
calc_loocv_rmse = function(model) {
sqrt(mean((resid(model) / (1 - hatvalues(model))) ^ 2))
}
calc_rmse = function(actual, predicted) {
sqrt(sum((actual - predicted)^2) / length(actual))
}
predicted_best = predict(back_twoway_mod_finish_aic, housing_tst_data)
calc_rmse(housing_tst_data$median_house_value)
predicted_best = predict(back_twoway_mod_finish_aic, housing_tst_data)
calc_rmse(housing_tst_data$median_house_value, predicted_best)
back_twoway_mod_finish_aic$call
back_twoway_mod_finish_aic_log = lm(formula = log(median_house_value) ~ longitude + latitude + housing_median_age +
total_rooms + total_bedrooms + population + households +
median_income + ocean_proximity + longitude:latitude + longitude:housing_median_age +
longitude:total_rooms + longitude:total_bedrooms + longitude:households +
longitude:median_income + longitude:ocean_proximity + latitude:housing_median_age +
latitude:total_rooms + latitude:total_bedrooms + latitude:median_income +
latitude:ocean_proximity + housing_median_age:total_rooms +
housing_median_age:population + housing_median_age:households +
housing_median_age:median_income + housing_median_age:ocean_proximity +
total_rooms:population + total_rooms:households + total_rooms:median_income +
total_rooms:ocean_proximity + total_bedrooms:households +
total_bedrooms:median_income + total_bedrooms:ocean_proximity +
population:households + population:median_income + population:ocean_proximity +
households:median_income + households:ocean_proximity + median_income:ocean_proximity,
data = housing_trn_data)
diagnostics(back_twoway_mod_finish_aic_log)
