kable(t(test_results), col.names = c("Test Statistic", "P-Value", "Decision"))
}
}
diagnostics(back_twoway_mod_finish_aic)
diagnostics(best_leaps_model_1)
diagnostics(back_aic_mod_2)
diagnostics(best_leaps_model_3)
?ad_test
library(nortest)
?ad.test
back_twoway_mod_finish_aic
back_twoway_mod_finish_aic$model
back_twoway_mod_finish_aic$call
back_twoway_mod_finish_aic_log = lm(formula = log(median_house_value) ~ longitude + latitude + housing_median_age +
total_rooms + total_bedrooms + population + households +
median_income + ocean_proximity + avg_bedrooms_per_household +
longitude:latitude + longitude:housing_median_age + longitude:total_rooms +
longitude:total_bedrooms + longitude:households + longitude:median_income +
longitude:ocean_proximity + longitude:avg_bedrooms_per_household +
latitude:housing_median_age + latitude:total_rooms + latitude:total_bedrooms +
latitude:households + latitude:median_income + latitude:ocean_proximity +
latitude:avg_bedrooms_per_household + housing_median_age:total_rooms +
housing_median_age:total_bedrooms + housing_median_age:population +
housing_median_age:households + housing_median_age:median_income +
housing_median_age:ocean_proximity + housing_median_age:avg_bedrooms_per_household +
total_rooms:population + total_rooms:households + total_rooms:median_income +
total_rooms:ocean_proximity + total_bedrooms:households +
total_bedrooms:median_income + total_bedrooms:ocean_proximity +
population:households + population:median_income + population:ocean_proximity +
population:avg_bedrooms_per_household + households:median_income +
households:ocean_proximity + median_income:ocean_proximity +
median_income:avg_bedrooms_per_household + ocean_proximity:avg_bedrooms_per_household, data = housing_trn_data)
diagnostics(back_twoway_mod_finish_aic_log)
library(lmtest)
library(knitr)
back_twoway_mod_finish_aic_log = lm(formula = log(median_house_value) ~ longitude + latitude + housing_median_age +
total_rooms + total_bedrooms + population + households +
median_income + ocean_proximity + avg_bedrooms_per_household +
longitude:latitude + longitude:housing_median_age + longitude:total_rooms +
longitude:total_bedrooms + longitude:households + longitude:median_income +
longitude:ocean_proximity + longitude:avg_bedrooms_per_household +
latitude:housing_median_age + latitude:total_rooms + latitude:total_bedrooms +
latitude:households + latitude:median_income + latitude:ocean_proximity +
latitude:avg_bedrooms_per_household + housing_median_age:total_rooms +
housing_median_age:total_bedrooms + housing_median_age:population +
housing_median_age:households + housing_median_age:median_income +
housing_median_age:ocean_proximity + housing_median_age:avg_bedrooms_per_household +
total_rooms:population + total_rooms:households + total_rooms:median_income +
total_rooms:ocean_proximity + total_bedrooms:households +
total_bedrooms:median_income + total_bedrooms:ocean_proximity +
population:households + population:median_income + population:ocean_proximity +
population:avg_bedrooms_per_household + households:median_income +
households:ocean_proximity + median_income:ocean_proximity +
median_income:avg_bedrooms_per_household + ocean_proximity:avg_bedrooms_per_household, data = housing_trn_data)
diagnostics(back_twoway_mod_finish_aic_log)
diagnostics(back_twoway_mod_finish_aic)
# From the text: http://daviddalpiaz.github.io/appliedstats/variable-selection-and-model-building.html
calc_loocv_rmse = function(model) {
sqrt(mean((resid(model) / (1 - hatvalues(model))) ^ 2))
}
calc_loocv_rmse(back_twoway_mod_finish_aic)
calc_loocv_rmse(best_exhaustive_model_1)
best_exhaustive_model_1 = lm(median_house_value ~ longitude + latitude + I(ocean_proximity == "INLAND") + I(ocean_proximity == "NEAR BAY") + longitude:latitude + longitude:median_income + longitude:I(ocean_proximity == "NEAR BAY") + housing_median_age:total_rooms + housing_median_age:population + population:median_income, data = housing_trn_data)
summary(best_exhaustive_model_1)$"adj.r.squared"
#names(coef(best_exhaustive_model_1))[-1]
best_exhaustive_model_2 = lm(median_house_value ~ housing_median_age + I(ocean_proximity == "INLAND") + I(ocean_proximity == "NEAR BAY") + longitude:housing_median_age + longitude:median_income + longitude:I(ocean_proximity == "NEAR BAY") + housing_median_age:total_rooms + housing_median_age:population, data = housing_trn_data)
summary(best_exhaustive_model_2)$"adj.r.squared"
#names(coef(best_exhaustive_model_2))[-1]
best_exhaustive_model_3 = lm(median_house_value ~ median_income + I(ocean_proximity == "INLAND") + I(ocean_proximity == "NEAR BAY") + longitude:median_income + latitude:median_income + longitude:I(ocean_proximity == "NEAR BAY") + housing_median_age:total_rooms + housing_median_age:population, data = housing_trn_data)
summary(best_exhaustive_model_3)$"adj.r.squared"
#names(coef(best_exhaustive_model_3))[-1]
calc_loocv_rmse(back_twoway_mod_finish_aic)
calc_loocv_rmse(best_exhaustive_model_1)
calc_loocv_rmse(back_aic_mod_2)
calc_loocv_rmse(best_exhaustive_model_3)
housing_tst_data
housing_data$ocean_proximity = as.factor(housing_data$ocean_proximity)
levels(housing_data$ocean_proximity)
housing_data = housing_data[housing_data$ocean_proximity != "ISLAND", ]
housing_data$total_bedrooms[is.na(housing_data$total_bedrooms)] = bedroom_median
set.seed(420)
housing_trn_idx = createDataPartition(housing_data$ocean_proximity, p = .70, list = FALSE)
library(boot)
set.seed(420)
housing_trn_idx = createDataPartition(housing_data$ocean_proximity, p = .70, list = FALSE)
library(mice)
library(caret)
set.seed(420)
housing_trn_idx = createDataPartition(housing_data$ocean_proximity, p = .70, list = FALSE)
housing_trn_data = housing_data[housing_trn_idx, ]
housing_tst_data = housing_data[-housing_trn_idx, ]
predicted_best = predict(back_twoway_mod_finish_aic, housing_tst_data)
full_twoway_model = twoway_mod_start = lm(median_house_value ~ (.)^2, data = housing_trn_data)
twoway_adjr2 = summary(full_twoway_model)$adj.r.squared
# full_twoway_model
# AIC
back_twoway_mod_finish_aic = step(full_twoway_model, direction = "backward", trace = 0)
both_twoway_mod_finish_aic = step(full_twoway_model, direction = "both", trace = 0)
# BIC
n = length(resid(full_twoway_model))
back_twoway_mod_finish_bic = step(full_twoway_model, direction = "backward", k = log(n), trace = 0)
both_twoway_mod_finish_bic = step(full_twoway_model, direction = "both", k = log(n), trace = 0)
# best_exhaustive_model_1
# AIC
back_aic_mod_1 = step(best_exhaustive_model_1, direction = "backward", trace = 0)
both_aic_mod_1 = step(best_exhaustive_model_1, direction = "both", trace = 0)
# BIC
n = length(resid(best_exhaustive_model_1))
back_bic_mod_1 = step(best_exhaustive_model_1, direction = "backward", k = log(n), trace = 0)
both_bic_mod_1 = step(best_exhaustive_model_1, direction = "both", k = log(n), trace = 0)
# best_exhaustive_model_2
# AIC
back_aic_mod_2 = step(best_exhaustive_model_2, direction = "backward", trace = 0)
both_aic_mod_2 = step(best_exhaustive_model_2, direction = "both", trace = 0)
# BIC
n = length(resid(best_exhaustive_model_2))
back_bic_mod_2 = step(best_exhaustive_model_2, direction = "backward", k = log(n), trace = 0)
both_bic_mod_2 = step(best_exhaustive_model_2, direction = "both", k = log(n), trace = 0)
# best_exhaustive_model_3
# AIC
back_aic_mod_3 = step(best_exhaustive_model_3, direction = "backward", trace = 0)
both_aic_mod_3 = step(best_exhaustive_model_3, direction = "both", trace = 0)
# BIC
n = length(resid(best_exhaustive_model_3))
back_bic_mod_3 = step(best_exhaustive_model_3, direction = "backward", k = log(n), trace = 0)
both_bic_mod_3 = step(best_exhaustive_model_2, direction = "both", k = log(n), trace = 0)
calc_loocv_rmse(back_twoway_mod_finish_aic)
calc_loocv_rmse(best_exhaustive_model_1)
calc_loocv_rmse(back_aic_mod_2)
calc_loocv_rmse(best_exhaustive_model_3)
predicted_best = predict(back_twoway_mod_finish_aic, housing_tst_data)
calc_rmse(housing_tst_data$median_house_value)
# From the text: http://daviddalpiaz.github.io/appliedstats/variable-selection-and-model-building.html
calc_loocv_rmse = function(model) {
sqrt(mean((resid(model) / (1 - hatvalues(model))) ^ 2))
}
calc_rmse = function(actual, predicted) {
sqrt(sum((actual - predicted)^2) / length(actual))
}
predicted_best = predict(back_twoway_mod_finish_aic, housing_tst_data)
calc_rmse(housing_tst_data$median_house_value)
predicted_best = predict(back_twoway_mod_finish_aic, housing_tst_data)
calc_rmse(housing_tst_data$median_house_value, predicted_best)
back_twoway_mod_finish_aic$call
back_twoway_mod_finish_aic_log = lm(formula = log(median_house_value) ~ longitude + latitude + housing_median_age +
total_rooms + total_bedrooms + population + households +
median_income + ocean_proximity + longitude:latitude + longitude:housing_median_age +
longitude:total_rooms + longitude:total_bedrooms + longitude:households +
longitude:median_income + longitude:ocean_proximity + latitude:housing_median_age +
latitude:total_rooms + latitude:total_bedrooms + latitude:median_income +
latitude:ocean_proximity + housing_median_age:total_rooms +
housing_median_age:population + housing_median_age:households +
housing_median_age:median_income + housing_median_age:ocean_proximity +
total_rooms:population + total_rooms:households + total_rooms:median_income +
total_rooms:ocean_proximity + total_bedrooms:households +
total_bedrooms:median_income + total_bedrooms:ocean_proximity +
population:households + population:median_income + population:ocean_proximity +
households:median_income + households:ocean_proximity + median_income:ocean_proximity,
data = housing_trn_data)
diagnostics(back_twoway_mod_finish_aic_log)
full_additive_model = lm(median_house_value ~ ., data = housing_trn_data)
full_additive_adjr2 = summary(full_additive_model)$adj.r.squared
full_twoway_model = lm(median_house_value ~ (.)^2, data = housing_trn_data)
full_twoway_adjr2 = summary(full_twoway_model)$adj.r.squared
full_threeway_model = lm(median_house_value ~ (.)^3, data = housing_trn_data)
full_threeway_adjr2 = summary(full_threeway_model)$adj.r.squared
beginning_mods_results = data.frame(
"Total Predictors" = c("Additive Model" = extractAIC(full_additive_model)[1],
"Two-Way Int. Model" = extractAIC(full_twoway_model)[1],
"Three-Way Int. Model" = extractAIC(full_threeway_model)[1]
),
"AIC" = c("Additive Model" = extractAIC(full_additive_model)[2],
"Two-Way Int. Model" = extractAIC(full_twoway_model)[2],
"Three-Way Int. Model" = extractAIC(full_threeway_model)[2]
),
"Adj. R-Squared" = c("Additive Model" = full_additive_adjr2,
"Two-Way Int. Model" = full_twoway_adjr2,
"Three-Way Int. Model" = full_threeway_adjr2
)
)
kable(aic_beginning_mods, align = c("c", "r"))
if(!require(Cairo)) install.packages("Cairo", repos = "http://cran.us.r-project.org")
if(!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
if(!require(car)) install.packages("car", repos = "http://cran.us.r-project.org")
if(!require(nortest)) install.packages("nortest", repos = "http://cran.us.r-project.org")
library(readr)
library(ggplot2)
library(knitr)
library(tidyverse)
library(caret)
library(leaps)
library(car)
library(mice)
library(scales)
library(RColorBrewer)
library(plotly)
library(nortest)
library(lmtest)
beginning_mods_results = data.frame(
"Total Predictors" = c("Additive Model" = extractAIC(full_additive_model)[1],
"Two-Way Int. Model" = extractAIC(full_twoway_model)[1],
"Three-Way Int. Model" = extractAIC(full_threeway_model)[1]
),
"AIC" = c("Additive Model" = extractAIC(full_additive_model)[2],
"Two-Way Int. Model" = extractAIC(full_twoway_model)[2],
"Three-Way Int. Model" = extractAIC(full_threeway_model)[2]
),
"Adj. R-Squared" = c("Additive Model" = full_additive_adjr2,
"Two-Way Int. Model" = full_twoway_adjr2,
"Three-Way Int. Model" = full_threeway_adjr2
)
)
kable(aic_beginning_mods, align = c("c", "r"))
beginning_mods_results = data.frame(
"Total Predictors" = c("Additive Model" = extractAIC(full_additive_model)[1],
"Two-Way Int. Model" = extractAIC(full_twoway_model)[1],
"Three-Way Int. Model" = extractAIC(full_threeway_model)[1]
),
"AIC" = c("Additive Model" = extractAIC(full_additive_model)[2],
"Two-Way Int. Model" = extractAIC(full_twoway_model)[2],
"Three-Way Int. Model" = extractAIC(full_threeway_model)[2]
),
"Adj. R-Squared" = c("Additive Model" = full_additive_adjr2,
"Two-Way Int. Model" = full_twoway_adjr2,
"Three-Way Int. Model" = full_threeway_adjr2
)
)
kable(beginning_mods_results, align = c("c", "r"))
beginning_mods_results = data.frame(
"Total Predictors" = c("Additive Model" = extractAIC(full_additive_model)[1],
"Two-Way Int. Model" = extractAIC(full_twoway_model)[1],
"Three-Way Int. Model" = extractAIC(full_threeway_model)[1]
),
"AIC" = c("Additive Model" = extractAIC(full_additive_model)[2],
"Two-Way Int. Model" = extractAIC(full_twoway_model)[2],
"Three-Way Int. Model" = extractAIC(full_threeway_model)[2]
),
"Adj R-Squared" = c("Additive Model" = full_additive_adjr2,
"Two-Way Int. Model" = full_twoway_adjr2,
"Three-Way Int. Model" = full_threeway_adjr2
)
)
kable(beginning_mods_results, align = c("c", "r"))
back_additive_mod_finish_aic = step(full_additive_model, direction = "backward", trace = 0)
both_additive_mod_finish_aic = step(full_additive_model, direction = "both", trace = 0)
n = length(resid(full_additive_model))
back_additive_mod_finish_bic = step(full_additive_model, direction = "backward", k = log(n), trace = 0)
both_additive_mod_finish_bic = step(full_additive_model, direction = "both", k = log(n), trace = 0)
back_twoway_mod_finish_aic = step(full_twoway_model, direction = "backward", trace = 0)
both_twoway_mod_finish_aic = step(full_twoway_model, direction = "both", trace = 0)
n = length(resid(full_twoway_model))
back_twoway_mod_finish_bic = step(full_twoway_model, direction = "backward", k = log(n), trace = 0)
both_twoway_mod_finish_bic = step(full_twoway_model, direction = "both", k = log(n), trace = 0)
back_threeway_mod_finish_aic = step(full_threeway_model, direction = "backward", trace = 0)
back_threeway_mod_finish_aic = step(full_threeway_model, direction = "backward", trace = FALSE)
test = matrix(housing_trn_data[, -c("median_house_value")])
housing_trn_data
housing_trn_data$avg_bedrooms_per_household
housing_data = read_csv("housing.csv")
housing_data$ocean_proximity = as.factor(housing_data$ocean_proximity)
levels(housing_data$ocean_proximity)
housing_data = housing_data[housing_data$ocean_proximity != "ISLAND", ]
housing_data$total_bedrooms[is.na(housing_data$total_bedrooms)] = bedroom_median
set.seed(420)
housing_trn_idx = createDataPartition(housing_data$ocean_proximity, p = .70, list = FALSE)
housing_trn_data = housing_data[housing_trn_idx, ]
housing_tst_data = housing_data[-housing_trn_idx, ]
housing_trn_data
full_additive_model = lm(median_house_value ~ ., data = housing_trn_data)
full_additive_adjr2 = summary(full_additive_model)$adj.r.squared
full_twoway_model = lm(median_house_value ~ (.)^2, data = housing_trn_data)
full_twoway_adjr2 = summary(full_twoway_model)$adj.r.squared
full_threeway_model = lm(median_house_value ~ (.)^3, data = housing_trn_data)
full_threeway_adjr2 = summary(full_threeway_model)$adj.r.squared
length(coef(full_threeway_model))
beginning_mods_results = data.frame(
"Total Predictors" = c("Additive Model" = extractAIC(full_additive_model)[1],
"Two-Way Int. Model" = extractAIC(full_twoway_model)[1],
"Three-Way Int. Model" = extractAIC(full_threeway_model)[1]
),
"AIC" = c("Additive Model" = extractAIC(full_additive_model)[2],
"Two-Way Int. Model" = extractAIC(full_twoway_model)[2],
"Three-Way Int. Model" = extractAIC(full_threeway_model)[2]
),
"Adj R-Squared" = c("Additive Model" = full_additive_adjr2,
"Two-Way Int. Model" = full_twoway_adjr2,
"Three-Way Int. Model" = full_threeway_adjr2
)
)
kable(beginning_mods_results, align = c("c", "r"))
back_additive_mod_finish_aic = step(full_additive_model, direction = "backward", trace = 0)
both_additive_mod_finish_aic = step(full_additive_model, direction = "both", trace = 0)
n = length(resid(full_additive_model))
back_additive_mod_finish_bic = step(full_additive_model, direction = "backward", k = log(n), trace = 0)
both_additive_mod_finish_bic = step(full_additive_model, direction = "both", k = log(n), trace = 0)
back_twoway_mod_finish_aic = step(full_twoway_model, direction = "backward", trace = 0)
both_twoway_mod_finish_aic = step(full_twoway_model, direction = "both", trace = 0)
housing_trn_data[, 10]
housing_trn_data[, 9]
test = housing_trn_data[, -9]
test
X = as.matrix(test)
X
install.packages("glmnet")
library(glmnet)
testfit = fit(x = X, y = housing_trn_data$median_house_value, alpha = 1)
testfit = glmnet(x = X, y = housing_trn_data$median_house_value, alpha = 1)
testfit
install.packages("ridge")
library(ridge)
testmod = linearRidge(median_house_value ~ (.)^2, housing_trn_data)
testmod = linearRidge(median_house_value ~ ., housing_trn_data)
housing_trn_data
summary(housing_trn_data)
test = housing_trn_data[, -10]
testmod = linearRidge(median_house_value ~ ., test)
coef(testmod)
testmod = linearRidge(median_house_value ~ (.)^2, test)
coef(testmod)
length(coef(testmod)
length(coef(testmod))
length(coef(testmod))
length(coef(full_twoway_model))
coef(back_twoway_mod_finish_bic)
back_additive_mod_finish_aic = step(full_additive_model, direction = "backward", trace = 0)
both_additive_mod_finish_aic = step(full_additive_model, direction = "both", trace = 0)
n = length(resid(full_additive_model))
back_additive_mod_finish_bic = step(full_additive_model, direction = "backward", k = log(n), trace = 0)
both_additive_mod_finish_bic = step(full_additive_model, direction = "both", k = log(n), trace = 0)
back_twoway_mod_finish_aic = step(full_twoway_model, direction = "backward", trace = 0)
both_twoway_mod_finish_aic = step(full_twoway_model, direction = "both", trace = 0)
n = length(resid(full_twoway_model))
back_twoway_mod_finish_bic = step(full_twoway_model, direction = "backward", k = log(n), trace = 0)
both_twoway_mod_finish_bic = step(full_twoway_model, direction = "both", k = log(n), trace = 0)
back_threeway_mod_finish_aic = step(full_threeway_model, direction = "backward", trace = FALSE)
coef(back_twoway_mod_finish_aic)
back_threeway_mod_finish_aic = step(full_threeway_model, direction = "backward", trace = FALSE, steps = 50)
back_additive_mod_finish_aic = step(full_additive_model, direction = "backward", trace = 0)
both_additive_mod_finish_aic = step(full_additive_model, direction = "both", trace = 0)
n = length(resid(full_additive_model))
back_additive_mod_finish_bic = step(full_additive_model, direction = "backward", k = log(n), trace = 0)
both_additive_mod_finish_bic = step(full_additive_model, direction = "both", k = log(n), trace = 0)
back_twoway_mod_finish_aic = step(full_twoway_model, direction = "backward", trace = 0)
both_twoway_mod_finish_aic = step(full_twoway_model, direction = "both", trace = 0)
n = length(resid(full_twoway_model))
back_twoway_mod_finish_bic = step(full_twoway_model, direction = "backward", k = log(n), trace = 0)
both_twoway_mod_finish_bic = step(full_twoway_model, direction = "both", k = log(n), trace = 0)
aic_and_bic_results = data.frame(
"AIC" =
c("Backward" =
c("Additive" = extractAIC(back_additive_mod_finish_aic)[2],
"Two-Way" = extractAIC(back_twoway_mod_finish_aic)[2],
"Three-way" = extractAIC(full_threeway_model)[2]),
"Both" =
c("Additive" = extractAIC(both_additive_mod_finish_aic)[2],
"Two-Way" = extractAIC(both_twoway_mod_finish_aic)[2],
"Three-way" = extractAIC(full_threeway_model)[2]),
"BIC" =
c("Backward" =
c("Additive" = extractAIC(back_additive_mod_finish_bic)[2],
"Two-Way" = extractAIC(back_twoway_mod_finish_bic)[2],
"Three-way" = extractAIC(full_threeway_model)[2]),
"Both" =
c("Additive" = extractAIC(both_additive_mod_finish_bic)[2],
"Two-Way" = extractAIC(both_twoway_mod_finish_bic)[2],
"Three-way" = extractAIC(full_threeway_model)[2]))))
kable(aic_and_bic_results)
aic_and_bic_results = data.frame(
"AIC" =
c("Backward" =
c("Additive" = extractAIC(back_additive_mod_finish_aic)[2],
"Two-Way" = extractAIC(back_twoway_mod_finish_aic)[2],
"Three-way" = extractAIC(full_threeway_model)[2]),
"Both" =
c("Additive" = extractAIC(both_additive_mod_finish_aic)[2],
"Two-Way" = extractAIC(both_twoway_mod_finish_aic)[2],
"Three-way" = extractAIC(full_threeway_model)[2])),
"BIC" =
c("Backward" =
c("Additive" = extractAIC(back_additive_mod_finish_bic)[2],
"Two-Way" = extractAIC(back_twoway_mod_finish_bic)[2],
"Three-way" = extractAIC(full_threeway_model)[2]),
"Both" =
c("Additive" = extractAIC(both_additive_mod_finish_bic)[2],
"Two-Way" = extractAIC(both_twoway_mod_finish_bic)[2],
"Three-way" = extractAIC(full_threeway_model)[2]))))
aic_and_bic_results = data.frame(
"AIC" =
c("Backward" =
c("Additive" = extractAIC(back_additive_mod_finish_aic)[2],
"Two-Way" = extractAIC(back_twoway_mod_finish_aic)[2],
"Three-way" = extractAIC(full_threeway_model)[2]),
"Both" =
c("Additive" = extractAIC(both_additive_mod_finish_aic)[2],
"Two-Way" = extractAIC(both_twoway_mod_finish_aic)[2],
"Three-way" = extractAIC(full_threeway_model)[2])),
"BIC" =
c("Backward" =
c("Additive" = extractAIC(back_additive_mod_finish_bic)[2],
"Two-Way" = extractAIC(back_twoway_mod_finish_bic)[2],
"Three-way" = extractAIC(full_threeway_model)[2]),
"Both" =
c("Additive" = extractAIC(both_additive_mod_finish_bic)[2],
"Two-Way" = extractAIC(both_twoway_mod_finish_bic)[2],
"Three-way" = extractAIC(full_threeway_model)[2])))
kable(aic_and_bic_results)
extractAIC(back_twoway_mod_finish_aic)
extractAIC(both_twoway_mod_finish_aic)
coef(back_twoway_mod_finish_aic) == coef(both_twoway_mod_finish_aic)
coef(back_twoway_mod_finish_aic)[back_twoway_mod_finish_aic == both_twoway_mod_finish_aic]
name(coef(back_twoway_mod_finish_aic))[back_twoway_mod_finish_aic == both_twoway_mod_finish_aic]
length(coef(back_twoway_mod_finish_aic))
length(coef(back_twoway_mod_finish_aic) == coef(both_twoway_mod_finish_aic))
identical(back_twoway_mod_finish_aic, both_twoway_mod_finish_aic)
diagnostics = function(model, alpha = .05, pointcol = "orange", linecol = "blue", plots = TRUE, tests = TRUE, pointtype = 16) {
if (plots == TRUE) {
par(mfrow = c(1, 3))
plot(
fitted(model),
resid(model),
pch = pointtype,
xlab = "Fitted Values",
ylab = "Residuals",
main = "Fitted vs Residuals",
col = pointcol
)
abline(h = 0, lwd = 2, col = linecol)
qqnorm(
resid(model),
pch = pointtype,
main = "QQNorm Plot",
col = pointcol
)
qqline(
resid(model),
lwd = 2,
col = linecol
)
hist(
resid(model),
main = "Histogram of Residuals",
col = pointcol,
xlab = "Residuals",
ylab = "Frequency"
)
}
if (tests == TRUE) {
ad_test = ad.test(resid(model))
bp_test = bptest(model)
test_results = data.frame(
"Anderson-Darling Normality Test" = c("Test Statistic" = round(ad_test$statistic, 5),
"P-Value" = ad_test$p.value,
"Result" = ifelse(ad_test$p.value < alpha, "Reject", "Fail To Reject")
),
"Breusch-Pagan Test" = c("Test Statistic" = round(bp_test$statistic, 5),
"P-Value" = bp_test$p.value,
"Result" = ifelse(bp_test$p.value < alpha, "Reject", "Fail To Reject")
)
)
kable(t(test_results), col.names = c("Test Statistic", "P-Value", "Decision"))
}
}
diagnostics(back_additive_mod_finish_aic)
diagnostics(back_twoway_mod_finish_aic)
diagnostics(full_threeway_model)
back_twoway_mod_finish_aic$call
back_twoway_mod_finish_aic_log = lm(formula = log(median_house_value) ~ longitude + latitude + housing_median_age +
total_rooms + total_bedrooms + population + households +
median_income + ocean_proximity + longitude:latitude + longitude:housing_median_age +
longitude:total_rooms + longitude:total_bedrooms + longitude:households +
longitude:median_income + longitude:ocean_proximity + latitude:housing_median_age +
latitude:total_rooms + latitude:total_bedrooms + latitude:median_income +
latitude:ocean_proximity + housing_median_age:total_rooms +
housing_median_age:population + housing_median_age:households +
housing_median_age:median_income + housing_median_age:ocean_proximity +
total_rooms:population + total_rooms:households + total_rooms:median_income +
total_rooms:ocean_proximity + total_bedrooms:households +
total_bedrooms:median_income + total_bedrooms:ocean_proximity +
population:households + population:median_income + population:ocean_proximity +
households:median_income + households:ocean_proximity + median_income:ocean_proximity,
data = housing_trn_data)
diagnostics(back_twoway_mod_finish_aic_log)
additive_loocv_rmse = calc_loocv_rmse(back_additive_mod_finish_aic)
# From the text: http://daviddalpiaz.github.io/appliedstats/variable-selection-and-model-building.html
calc_loocv_rmse = function(model) {
sqrt(mean((resid(model) / (1 - hatvalues(model))) ^ 2))
}
calc_rmse = function(actual, predicted) {
sqrt(sum((actual - predicted)^2) / length(actual))
}
additive_loocv_rmse = calc_loocv_rmse(back_additive_mod_finish_aic)
twoway_loocv_rmse = calc_loocv_rmse(back_twoway_mod_finish_aic)
threeway_loocv_rmse = calc_loocv_rmse(full_threeway_model)
loocv_rmse_results = data.frame(
"LOOCV-RMSE" = c(
"Backwards Additive" = additive_loocv_rmse,
"Backwards Two-Way" = twoway_loocv_rmse,
"Initial Three-way" = threeway_loocv_rmse
)
)
kable(loocv_rmse_results)
calc_avg_per_error = function(actual, predicted) {
inter_abs = abs(predicted - actual)
100 * (sum(inter_abs / actual)) / length(actual)
}
# the actual median house values from the test set
test_actual = housing_tst_data$median_house_value
test_predictions = predict(back_twoway_mod_finish_aic, housing_tst_data)
test_rmse = calc_rmse(test_actual, test_predictions)
test_perc_error = calc_avg_per_error(test_actual, test_predictions)
test_perc_error
test_rmse
